#+AUTHOR: zhufuge
#+DATE: <2017-04-21 周五 13:25>


* Mtrx
** discription
  Mtrx is a calculation library for matrix.

  The library has only an Object -- Mtrx.

  Mtrx is extends Array, is arrays of Numbers.

** create
   It is really easy to create a matrix object what you want.
  
  #+BEGIN_SRC js
    // No arguments, create a 1×1 random(0 ~ 1) matrix
    new Mtrx()
    // -> Mtrx [ [ 0.7173410249746024 ] ]

    // Get a number, create a n×n random(0 ~ 1) matrix
    new Mtrx(2)
    // -> Mtrx [
    //  [ 0.9028933497295337, 0.18980748816858917 ],
    //  [ 0.10859200880292263, 0.560035422729191 ] ]

    // Get two numbers, create a n×m random(0 ~ 1) matrix
    new Mtrx(2, 3)
    // -> Mtrx [
    //  [ 0.6974184450003136, 0.6402339494410889, 0.4553998131618524 ],
    //  [ 0.38759912033793165, 0.8904429716538196, 0.7449091649551736 ] ]

    // Get three numbers, create a n×m x matrix
    new Mtrx(3, 4, 9)
    // -> Mtrx [ [ 9, 9, 9, 9 ], [ 9, 9, 9, 9 ], [ 9, 9, 9, 9 ] ]

    // Get numbers array, create a diag matrix
    new Mtrx([2, 4, 6])
    // -> Mtrx [ [ 2, 0, 0 ], [ 0, 4, 0 ], [ 0, 0, 6 ] ]

    // Get a 2-order numbers array, create a matrix like the array
    new Mtrx([[1, 2, 3], [4, 5, 6]])
    // -> Mtrx [ [ 1, 2, 3 ], [ 4, 5, 6 ] ]

    // Get two numbers and a function expression, create a matrix by the expression
    new Mtrx(2, 3, (i, j) => i + j)
    // -> Mtrx [ [ 0, 1, 2 ], [ 1, 2, 3 ] ]
  #+END_SRC

** operation
   Mtrx object is a Array-like object. So, you can operat it just like to operat a 2-order Array.

   #+BEGIN_SRC js
     const m = new Mtrx(2, 3, 0);
     // -> Mtrx [ [ 0, 0, 0 ], [ 0, 0, 0 ] ]

     m[0][1] = 1;
     // -> Mtrx [ [ 0, 1, 0 ], [ 0, 0, 0 ] ]
   #+END_SRC

** property
   Mtrx have many base properties.

   #+BEGIN_SRC js
     const m = new Mtrx(2, 3, (i, j) => (i === j) ? 1 : 0);
     // -> Mtrx [ [ 1, 0, 0 ], [ 0, 1, 0 ] ]
     const n = new Mtrx([
       [1, 2, 0],
       [3, 4, 4],
       [5, 6, 3]
     ]);
     // -> Mtrx [ [ 1, 2, 0 ], [ 3, 4, 4 ], [ 5, 6, 3 ] ]

     m.rows  // -> 2
     m.cols  // -> 3
     
     n.T
     // Calculate transpose matrix, return a new Mtrx object
     // -> Mtrx [
     // [ 1, 3, 5 ],
     // [ 2, 4, 6 ],
     // [ 0, 4, 3 ]
     // ]

     m.rank  // -> 2

     m[0][0] = 0;
     // -> Mtrx [ [ 0, 0, 0 ], [ 0, 1, 0 ] ]
     m.rank  // -> 1
     
     n.det  // -> 10
     m.det  // -> NaN
     // If the Mtrx object's rows and cols was not equal, det would be NaN

     n.LUP
     // -> { L: Mtrx [ [ 1, 0, 0 ], [ 0.2, 1, 0 ], [ 0.6, 0.5, 1 ] ],
     //      U: Mtrx [ [ 5, 6, 3 ], [ 0, 0.8, -0.6 ], [ 0, 0, 2.5 ] ],
     //      P: Mtrx [ [ 0, 0, 1 ], [ 1, 0, 0 ], [ 0, 1, 0 ] ] }
     n.LUP.L
     // -> Mtrx [ [ 1, 0, 0 ], [ 0.2, 1, 0 ], [ 0.6, 0.5, 1 ] ]

     n.inv
     // -> Mtrx [ [ -1.2, -0.6, 0.8 ], [ 1.1, 0.3, -0.4 ], [ -0.2, 0.4, -0.2 ] ]

     // If there is no corresponding matrix, you would get a Error.
     m.LUP
     m.inv
     m.compan
     // -> Error: ...
   #+END_SRC

** static function
   - zeros
   - ones
   - eye
   - rand
   - like
   - diag
   - clone
   - isMtrx
   - isMtrxLike
   - isDiag
   - isSameShape
   - add
   - sub
   - mul
   - div

** function
   - changeRows
   - changeCols
   - resetLike
   - add
   - sub
   - mul
   - rightMul
   - leftMul
   - div
   - rightDiv
   - leftDiv
   - cof
